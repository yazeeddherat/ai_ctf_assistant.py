import sys, subprocess, os, json
import google.generativeai as genai
from PyQt6.QtWidgets import *
from PyQt6.QtCore import QThread, pyqtSignal, QWaitCondition, QMutex, Qt
from PyQt6.QtGui import QFont, QColor

# --- Ø¥Ø¹Ø¯Ø§Ø¯ Gemini ---
# ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¶Ø¹ Ù…ÙØªØ§Ø­Ùƒ Ù‡Ù†Ø§
GEMINI_API_KEY = "YOUR_GEMINI_API_KEY" 
genai.configure(api_key=GEMINI_API_KEY)
# Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙ„Ø§Ø´ 1.5 Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù€ Logs
model = genai.GenerativeModel('gemini-1.5-flash')

class AutonomousBrain(QThread):
    log_signal = pyqtSignal(str, str)
    ask_permission_signal = pyqtSignal(str, str)
    status_signal = pyqtSignal(str)

    def __init__(self, target_ip, goal):
        super().__init__()
        self.ip = target_ip
        self.goal = goal
        self.mutex = QMutex()
        self.condition = QWaitCondition()
        self.approved = False
        self.history = [] # Ø³Ø¬Ù„ ÙƒØ§Ù…Ù„ Ù„ØªØ­Ù„ÙŠÙ„ Gemini

    def approve_command(self):
        self.approved = True
        self.condition.wakeAll()

    def run(self):
        # Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø§Ù„ÙØ­Øµ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
        current_cmd = f"nmap -sV -T4 {self.ip}"
        reason = "Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø§Ø³ØªÙƒØ´Ø§Ù (Reconnaissance) Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù…ÙØªÙˆØ­Ø©."

        for step in range(1, 15): # Ø²ÙŠØ§Ø¯Ø© Ø¹Ø¯Ø¯ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ù…Ø¹Ù‚Ø¯
            self.ask_permission_signal.emit(current_cmd, reason)
            
            # Ø§Ù†ØªØ¸Ø§Ø± Ù…ÙˆØ§ÙÙ‚Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            self.mutex.lock()
            self.condition.wait(self.mutex)
            self.mutex.unlock()
            
            if not self.approved: break

            self.log_signal.emit(f"\n[STEP {step}] Running: {current_cmd}", "#3498db")
            output = self.execute_cmd(current_cmd)
            
            # Ø¹Ø±Ø¶ Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„Ù†ØªÙŠØ¬Ø© ÙÙŠ Ø§Ù„ÙƒÙˆÙ†Ø³ÙˆÙ„
            self.log_signal.emit(f"Output received. Parsing data...", "#95a5a6")
            
            # ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø¬Ù„
            self.history.append({"step": step, "cmd": current_cmd, "result": output[:2000]})

            # Ø§Ø³ØªØ´Ø§Ø±Ø© Ø§Ù„Ø¹Ù‚Ù„ (Gemini)
            self.status_signal.emit("âš¡ Gemini AI is analyzing the chain...")
            analysis = self.think_with_gemini()
            
            current_cmd = analysis.get("COMMAND", "DONE")
            reason = analysis.get("REASON", "Mission complete or AI stopped.")

            if "DONE" in current_cmd.upper():
                self.log_signal.emit("\nğŸ¯ MISSION ACCOMPLISHED: Gemini states no further actions needed.", "#f1c40f")
                break
            
            self.approved = False

    def execute_cmd(self, cmd):
        try:
            # ØªÙ†ÙÙŠØ° Ø­Ù‚ÙŠÙ‚ÙŠ Ù…Ø¹ Ø¯Ù…Ø¬ Ø§Ù„Ø®Ø·Ø£ ÙˆØ§Ù„Ù…Ø®Ø±Ø¬
            return subprocess.check_output(cmd, shell=True, stderr=subprocess.STDOUT, text=True, timeout=300)
        except subprocess.TimeoutExpired:
            return "Error: Command timed out after 5 minutes."
        except Exception as e:
            return f"Execution Error: {str(e)}"

    def think_with_gemini(self):
        # Ø¨Ù†Ø§Ø¡ Ø³ÙŠØ§Ù‚ Ø°ÙƒÙŠ Ù„Ù€ Gemini
        history_summary = json.dumps(self.history, indent=2)
        
        prompt = f"""
        TARGET: {self.ip}
        GOAL: {self.goal}
        PREVIOUS STEPS:
        {history_summary}

        You are an elite automated penetration testing engine. 
        Analyze the output of the last command and decide the NEXT logical step.
        - If you found web ports (80, 443, 8080), suggest directory brute-forcing or vuln scanning.
        - If you found specific versions (e.g., vsftpd 2.3.4), suggest exploit search.
        - If you found credentials, suggest login or SSH attempt.
        - If the goal is reached (root access/flag found), return COMMAND: DONE.

        RESPONSE FORMAT (MANDATORY):
        REASON: [Short Arabic explanation]
        COMMAND: [Single Kali Linux command]
        """
        try:
            response = model.generate_content(prompt)
            raw_text = response.text
            # Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø¨Ø¯Ù‚Ø© Ø£ÙƒØ¨Ø±
            reason = raw_text.split("REASON:")[1].split("COMMAND:")[0].strip()
            command = raw_text.split("COMMAND:")[1].strip()
            return {"REASON": reason, "COMMAND": command}
        except:
            return {"REASON": "Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø¯ Ù…Ù† Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ", "COMMAND": "DONE"}

# --- ÙˆØ§Ø¬Ù‡Ø© GHENA AI Ø§Ù„Ù…Ø­Ø¯Ø«Ø© ---
class GhenaAI_V36(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("GHENA AI - Nexus Edition v36.0")
        self.setMinimumSize(1000, 850)
        self.setStyleSheet("background-color: #0f0f0f; color: #e0e0e0; font-family: 'Segoe UI';")
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout()

        # Target Control
        ctrl_layout = QHBoxLayout()
        self.ip_box = QLineEdit(); self.ip_box.setPlaceholderText("Target IP (e.g. 10.10.231.4)"); self.ip_box.setStyleSheet("padding: 8px; background: #1a1a1a; border: 1px solid #333;")
        self.goal_box = QComboBox(); self.goal_box.addItems(["Full Root Access", "User Flag", "Network Discovery"])
        self.goal_box.setStyleSheet("padding: 8px; background: #1a1a1a;")
        self.btn_run = QPushButton("START ATTACK CHAIN"); self.btn_run.setStyleSheet("background: #8e44ad; font-weight: bold; padding: 10px;")
        self.btn_run.clicked.connect(self.start_engine)
        ctrl_layout.addWidget(self.ip_box); ctrl_layout.addWidget(self.goal_box); ctrl_layout.addWidget(self.btn_run)
        layout.addLayout(ctrl_layout)

        # AI Decision Area
        self.decision_group = QGroupBox("AI Strategic Decision")
        self.decision_group.setStyleSheet("color: #00ffcc; border: 1px solid #00ffcc; margin-top: 10px;")
        dec_layout = QVBoxLayout()
        self.reason_label = QLabel("Waiting for AI analysis..."); self.reason_label.setWordWrap(True)
        self.cmd_display = QLineEdit(); self.cmd_display.setReadOnly(True); self.cmd_display.setStyleSheet("color: #ffaa00; font-family: monospace; font-size: 14px; background: #000;")
        self.btn_approve = QPushButton("APPROVE & EXECUTE"); self.btn_approve.setEnabled(False); self.btn_approve.setStyleSheet("background: #27ae60; color: white; height: 35px;")
        self.btn_approve.clicked.connect(self.approve)
        dec_layout.addWidget(self.reason_label); dec_layout.addWidget(self.cmd_display); dec_layout.addWidget(self.btn_approve)
        self.decision_group.setLayout(dec_layout)
        layout.addWidget(self.decision_group)

        # Console
        self.console = QTextEdit(); self.console.setReadOnly(True); self.console.setStyleSheet("background: #000; color: #00ff00; font-family: 'Consolas'; font-size: 11px; border: 1px solid #222;")
        layout.addWidget(QLabel("Real-time Output Log:"))
        layout.addWidget(self.console)

        self.status = QStatusBar(); self.setStatusBar(self.status)
        
        container = QWidget(); container.setLayout(layout); self.setCentralWidget(container)

    def start_engine(self):
        ip = self.ip_box.text().strip()
        if not ip: return
        self.console.clear()
        self.btn_run.setEnabled(False)
        self.brain = AutonomousBrain(ip, self.goal_box.currentText())
        self.brain.log_signal.connect(self.update_log)
        self.brain.ask_permission_signal.connect(self.prompt_user)
        self.brain.status_signal.connect(self.status.showMessage)
        self.brain.start()

    def prompt_user(self, cmd, reason):
        self.reason_label.setText(f"ğŸ’¡ REASON: {reason}")
        self.cmd_display.setText(cmd)
        self.btn_approve.setEnabled(True)

    def approve(self):
        self.btn_approve.setEnabled(False)
        self.brain.approve_command()

    def update_log(self, msg, color):
        self.console.append(f"<font color='{color}'>{msg}</font>")

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = GhenaAI_V36(); window.show()
    sys.exit(app.exec())
